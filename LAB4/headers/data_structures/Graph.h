//
// Created by Илья Атмажитов on 14.11.2024.
//

#ifndef LABORATORY4_GRAPH_H
#define LABORATORY4_GRAPH_H

#include <cstddef>
#include <cstdint>
#include "HashTable.h"
#include <sstream>
#include <fstream>
#include <string>

using namespace std;

struct Edge {
    size_t from;
    size_t to;
    int64_t weight;

    Edge(): from(0), to(0), weight(0) {}
    Edge(size_t from, size_t to, int64_t weight): from(from), to(to), weight(weight) {}
};

template <class T>
struct Vertex {
    size_t id;
    T value;
    ArraySequence<Edge> edges;

    Vertex(): id(0), value() {}
    Vertex(size_t key, const T & value): id(key), value(value) {}
};

template <class T>
std::ostream & operator<<(std::ostream & os, const Vertex<T> & vertex) {
    os << "{" << vertex.id << ", " << vertex.value;
    os << "{";
    for (int i = 0; i < vertex.edges.GetLength(); i++) {
        os << "(" << vertex.edges.Get(i).from << "->" << vertex.edges.Get(i).to
           << ": " << vertex.edges.Get(i).weight << "); ";
    }
    os << "}";
    return os;
}

template <class T>
class OrientedGraph {
private:
    HashTable<size_t, Vertex<T>> data;

    void removeEdgesPointingTo(size_t vertexId) {
        auto vertices = data.GetKeys();
        for (int i = 0; i < vertices.GetLength(); i++) {
            auto vertex = data.FindElem(vertices.Get(i));
            if (vertex == nullptr) continue;

            ArraySequence<Edge> newEdges;
            for (int j = 0; j < vertex->second.edges.GetLength(); j++) {
                if (vertex->second.edges.Get(j).to != vertexId) {
                    newEdges.Append(vertex->second.edges.Get(j));
                }
            }
            vertex->second.edges = newEdges;
        }
    }

public:
    OrientedGraph() = default;

    bool HasVertex(size_t id) const {
        return data.FindElem(id) != nullptr;
    }

    void AddVertex(size_t id, const T& value) {
        if (HasVertex(id)) {
            throw std::invalid_argument("Vertex with ID " + std::to_string(id) + " already exists!");
        }
        Vertex<T> new_vertex(id, value);
        data.Insert(id, new_vertex);
    }

    void AddEdge(size_t from, size_t to, int64_t weight = 1) {
        auto result = data.FindElem(from);
        if (result == nullptr) {
            throw std::logic_error("Vertex 'from' not found!");
        }

        if (data.FindElem(to) == nullptr) {
            throw std::logic_error("Vertex 'to' not found!");
        }

        result->second.edges.Append({from, to, weight});
    }

    void DeleteVertex(size_t id) {
        auto vertex = data.FindElem(id);
        if (vertex == nullptr) {
            throw std::logic_error("Vertex not found!");
        }

        removeEdgesPointingTo(id);

        vertex->second.edges = ArraySequence<Edge>();

        data.Erase(id);
    }

    void SetVertexData(size_t id, T newData) {
        auto vertex = data.FindElem(id);
        if (vertex != nullptr) {
            vertex->second.value = newData;
        } else {
            throw std::runtime_error("Vertex not found");
        }
    }

    void DeleteEdge(size_t from, size_t to) {
        auto vertex = data.FindElem(from);
        if (vertex == nullptr) {
            throw std::logic_error("Source vertex not found!");
        }

        ArraySequence<Edge> newEdges;
        bool edgeFound = false;

        for (int i = 0; i < vertex->second.edges.GetLength(); i++) {
            if (vertex->second.edges.Get(i).to != to) {
                newEdges.Append(vertex->second.edges.Get(i));
            } else {
                edgeFound = true;
            }
        }

        if (!edgeFound) {
            throw std::logic_error("Edge not found!");
        }

        vertex->second.edges = newEdges;
    }

    ArraySequence<Edge> GetNeighbours(size_t from) const {
        auto result = data.FindElem(from);
        if (result == nullptr) {
            throw std::logic_error("Vertex not found!");
        }

        return result->second.edges;
    }

    ArraySequence<Vertex<T>> GetAllVertices() const {
        ArraySequence<Vertex<T>> result;
        auto keys = data.GetKeys();
        for (int i = 0; i < keys.GetLength(); i++) {
            auto vertex = data.FindElem(keys.Get(i));
            if (vertex != nullptr) {
                result.Append(vertex->second);
            }
        }
        return result;
    }

    std::string GenerateGraphvizDot() const {
        std::stringstream dot;
        dot << "digraph G {\n";
        dot << "    // Graph visualization generated by Graphviz\n";

        auto vertices = data.GetKeys();
        for (int i = 0; i < vertices.GetLength(); i++) {
            size_t vertexId = vertices.Get(i);
            auto vertexPtr = data.FindElem(vertexId);
            if (vertexPtr == nullptr) continue;

            dot << "    " << vertexId << " [label=\"" << vertexId
                << ": " << vertexPtr->second.value << "\"];\n";

            for (int i = 0; i < vertexPtr->second.edges.GetLength(); ++i) {
                const Edge& edge = vertexPtr->second.edges.Get(i);
                dot << "    " << vertexId << " -> " << edge.to
                    << " [label=\"" << edge.weight << "\"];\n";
            }
        }

        dot << "}\n";
        return dot.str();
    }

    void SaveGraphvizFile(const std::string& filename) const {
        std::ofstream file(filename);
        if (!file.is_open()) {
            throw std::runtime_error("Could not open file for writing");
        }
        file << GenerateGraphvizDot();
        file.close();
    }

    void RenderGraph(const std::string& filename, const std::string& format = "png") const {
        SaveGraphvizFile(filename + ".dot");

        std::string command = "dot -T" + format + " " + filename + ".dot -o " + filename + "." + format;
        int result = system(command.c_str());

        if (result != 0) {
            throw std::runtime_error("Failed to render graph. Ensure Graphviz is installed.");
        }
    }
};



#endif //LABORATORY4_GRAPH_H